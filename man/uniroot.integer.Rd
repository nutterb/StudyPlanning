% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uniroot.integer.R
\name{uniroot.integer}
\alias{uniroot.integer}
\title{Find the root of a function to the nearest integer}
\source{
Fay, M.P.,Follmann, D.A., Halloran, M.E. (2007). Accounting for
variability in sample size estimation with applications to nonadherence
and estimation of variance and effect size Biometrics 63: 465--474.

\code{ssanv} package: \url{https://CRAN.R-project.org/package=ssanv}
}
\usage{
uniroot.integer(f, interval, lower = min(interval), upper = max(interval),
  step.power = 6, step.up = TRUE, pos.side = FALSE, print.steps = FALSE,
  maxiter = 1000, ...)
}
\arguments{
\item{f}{function for which a root is needed}

\item{interval}{an interval giving minimum and maximum allowable values for root}

\item{lower}{minimum allowable root}

\item{upper}{maximum allowable root}

\item{step.power}{initial step size is \code{2 ^ step.power}}

\item{step.up}{if \code{TRUE} steps up from \code{'lower'}, 
if \code{FALSE} steps down from \code{'upper'}}

\item{pos.side}{if \code{TRUE} finds integer, \code{i}, 
closest to the root such that \code{f(i) > zero}}

\item{print.steps}{if \code{TRUE}, prints iterations}

\item{maxiter}{maximum number of iterations}

\item{...}{additional arguments to \code{f}.}
}
\value{
A list of the following elements:
\itemize{
\item{root } the integer on the correct side of the root
\item{f.root	} value of f at root
\item{iter } number of times f was evaluated
}
}
\description{
Let \code{f} be a monotonic function that changes sign within 
the interval specified. If \code{f(i) = 0} for some \code{i} within the 
interval specified (including the ends of the interval), 
then the root is \code{i}. Otherwise if \code{pos.side = TRUE} 
(or \code{FALSE}) then \code{uniroot.integer} finds the integer \code{i} 
such that \code{f(i)} is closest to the sign change and is positive 
(or negative).

This function is borrowed from the \code{ssanv} package by Michael P. Fay.
It is copied to avoid adding unnecessary dependencies.
}
\details{
The algorithm evaluates \code{f(i)} iteratively, increasing 
(or decreasing if \code{step.up = FALSE}) \code{i} by \code{2 ^ step.power} 
until either \code{f(i) = 0} or \code{f(i)} switches sign. 
If \code{f(i)=0}, then stop. If \code{f(i)} switches sign, then the 
change in \code{i} is halved each iteration until convergence.
}
\note{
Unlike \code{uniroot}, the function is not automatically evaluated 
  at both extremes. This makes \code{uniroot.integer} an efficient method 
  to use when the calculation time of \code{f(i)} increases with the value 
  of \code{i}. For an example of the importance of this see 
  \code{ss.fromdata.pois} (in the \code{ssanv} package).
}
\examples{
root.func<-function(i) i - 500.1 
## initial step sizes = 2^2 =4
uniroot.integer(root.func,c(0,Inf),step.power=2)
## more efficient to use bigger initial step sizes = 2^10 =1024
uniroot.integer(root.func,c(0,Inf),step.power=10,print.steps=TRUE)
}
\author{
Michael P. Fay
}
\seealso{
\code{\link{uniroot}}
}

